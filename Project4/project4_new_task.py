# -*- coding: utf-8 -*-
"""Project4_new_task.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ln2md9c5qwB7bEaIDyLoPoNkUV-ycovV
"""

!pip install 'igraph'

from igraph import *
import json
import random
import numpy as np
from numpy import linalg
import itertools
import matplotlib.pyplot as plt
from scipy.spatial import Delaunay  # needed for triangulation
import os
import pandas as pd
from copy import deepcopy
import networkx as nx
from geopy.geocoders import Nominatim
import math

random.seed(2022)
np.random.seed(2022)

with open('los_angeles_censustracts.json') as f:
    census_tracts = json.loads(f.readline())

display_names = dict()
coordinates = dict()

for area in census_tracts['features']:
    id = int(area['properties']['MOVEMENT_ID'])
    display_name = area['properties']['DISPLAY_NAME']
    display_names[id] = display_name
    a = area['geometry']['coordinates'][0]
    coordinates[id] = np.array(a if type(a[0][0]) == float else a[0]).mean(axis=0)

#9
g = Graph(directed=False)
g.add_vertices(len(display_names))
g.vs['display_name'] = list(display_names.values())  # index = id - 1
g.vs['coordinates'] = list(coordinates.values())

g2 = Graph(directed=False)
g2.add_vertices(len(display_names))
g2.vs['display_name'] = list(display_names.values())
g2.vs['coordinates'] = list(coordinates.values())

month_filter = {12}  # for monthly aggregate data of 4th quarter, we can filter data based off of only December

edges = []
weights = []

with open('los_angeles-censustracts-2019-4-All-MonthlyAggregate.csv') as f:
    f.readline()  # skip the first line

    while True:
        line = f.readline()
        if line == '':
            break  # end of file

        vals = line.strip().split(',')

        # read edge info
        src, dest, month, dist = int(vals[0]), int(vals[1]), int(vals[2]), float(vals[3])

        # if data is not relevant, skip it
        if month not in month_filter:
            continue

        edges.append((src - 1, dest - 1))
        weights.append(dist)

month_filter2 = {3}  # for monthly aggregate data of 4th quarter, we can filter data based off of only December

edges2 = []
weights2 = []

with open('los_angeles-censustracts-2020-1-All-MonthlyAggregate.csv') as f2:
    f2.readline()  # skip the first line

    while True:
        line2 = f2.readline()
        if line2 == '':
            break  # end of file

        vals2 = line2.strip().split(',')

        # read edge info
        src2, dest2, month2, dist2 = int(vals2[0]), int(vals2[1]), int(vals2[2]), float(vals2[3])

        # if data is not relevant, skip it
        if month2 not in month_filter2:
            continue

        edges2.append((src2 - 1, dest2 - 1))
        weights2.append(dist2)

g.add_edges(edges)
g.es['weight'] = weights
del edges, weights

g2.add_edges(edges2)
g2.es['weight'] = weights2
del edges2, weights2

# keep only the giant connected component
components = g.components()
gcc = max(components, key=len)
vs_to_delete = [i for i in range(len(g.vs)) if i not in gcc]
g.delete_vertices(vs_to_delete)

# remove duplicate edges
g = g.simplify(combine_edges=dict(weight='mean'))  # combine duplicate edges

# keep only the giant connected component
components2 = g2.components()
gcc2 = max(components2, key=len)
vs_to_delete2 = [i for i in range(len(g2.vs)) if i not in gcc2]
g2.delete_vertices(vs_to_delete2)

# remove duplicate edges
g2 = g2.simplify(combine_edges=dict(weight='mean'))  # combine duplicate edges

mst = g.spanning_tree(weights=g.es['weight'])

mst2 = g2.spanning_tree(weights = g2.es['weight'])

map_img = plt.imread('map3.png')

tri = Delaunay(g.vs['coordinates']) #use the Delaunay function imported above

tri2 = Delaunay(g2.vs['coordinates'])

edges_to_induce = []

for i in range(tri.simplices.shape[0]):
    for col1, col2 in ((0, 1), (1, 2), (0, 2)):
        temp = (tri.simplices[i][col1], tri.simplices[i][col2])
        sorted(temp)
        if temp in edges_to_induce:
          continue
        else:
          if g.are_connected(temp[0], temp[1]):
            edges_to_induce.append(temp)
        #add the edges to edges_to_induce

edges_to_induce2 = []

for i in range(tri2.simplices.shape[0]):
    for col1, col2 in ((0, 1), (1, 2), (0, 2)):
        temp = (tri2.simplices[i][col1], tri2.simplices[i][col2])
        sorted(temp)
        if temp in edges_to_induce2:
          continue
        else:
          if g2.are_connected(temp[0], temp[1]):
            edges_to_induce2.append(temp)
        #add the edges to edges_to_induce

tri_g = g.subgraph_edges(edges_to_induce)

tri_g2 = g2.subgraph_edges(edges_to_induce2)

#17
trim_thresh = 800

edges_to_induce = tri_g.es.select(weight_le=trim_thresh)
tri_g_trimmed = tri_g.subgraph_edges(edges_to_induce)

edges_to_induce2 = tri_g2.es.select(weight_le=trim_thresh)
tri_g_trimmed2 = tri_g2.subgraph_edges(edges_to_induce2)

road_map = deepcopy(tri_g_trimmed)
len(road_map.vs), len(road_map.es)

road_map2 = deepcopy(tri_g_trimmed2)
len(road_map2.vs), len(road_map2.es)

edge_ends = np.array([[e.source, e.target] for e in road_map.es])
sources, targets = edge_ends[:, 0], edge_ends[:, 1]
distances = []
for e in road_map.es:
  s_n = road_map.vs[e.source]['coordinates']
  d_n = road_map.vs[e.target]['coordinates']
  a = s_n[0]-d_n[0]
  b = s_n[1]-d_n[1]
  c = math.sqrt(a**2 + b**2)
  distances.append(c)
#distances = #write here

edge_ends2 = np.array([[e.source, e.target] for e in road_map2.es])
sources2, targets2 = edge_ends2[:, 0], edge_ends2[:, 1]
distances2 = []
for e in road_map2.es:
  s_n = road_map2.vs[e.source]['coordinates']
  d_n = road_map2.vs[e.target]['coordinates']
  a = s_n[0]-d_n[0]
  b = s_n[1]-d_n[1]
  c = math.sqrt(a**2 + b**2)
  distances2.append(c)
#distances = #write here

road_map.es['geo_distance'] = distances
vcount = len(road_map.vs)
max(distances)

road_map2.es['geo_distance'] = distances2
vcount2 = len(road_map2.vs)

#boundaries: (-118.309486, 34.090574) top left; bottom right (-118.212078, 34.018242)

print(road_map.vs[0])

cs = road_map.vs['coordinates']
limit_coords = road_map.vs.select([idx for idx, coords in enumerate(cs) if coords[0] > -118.309486 and coords[0] < -118.212078 and coords[1] > 34.018242 and coords[1] < 34.090574])
small_g = road_map.subgraph(limit_coords)

cs2 = road_map2.vs['coordinates']
limit_coords2 = road_map2.vs.select([idx for idx, coords in enumerate(cs2) if coords[0] > -118.309486 and coords[0] < -118.212078 and coords[1] > 34.018242 and coords[1] < 34.090574])
small_g2 = road_map2.subgraph(limit_coords2)

print(len(small_g.vs))
print(len(small_g.es))

# plot the roads and highlight our new edges.
BBox = (-118.31, -118.20, 34.0, 34.1)
fig, ax = plt.subplots(figsize=(15, 15), dpi = 200)
#plt.figure(figsize=(15,15), dpi=200)
for e in small_g.es:
    start = e.source
    end = e.target
    cur_edge = sorted([start,end])

    v1 = small_g.vs[e.source]['coordinates']
    v2 = small_g.vs[e.target]['coordinates']
    data = np.vstack([v1, v2])
    x = data[:, 0]
    y = data[:, 1]
    #if cur_edge in new_time_edges:
    #    print(cur_edge)
        #print(v1, v2)
    #    plt.plot(x,y,'#FF0000')#, linewidth = 4)
    #else:
    plt.plot(x, y, '#8ab4f7')


ax.imshow(map_img, zorder = 0, extent = BBox, aspect = 'equal')
plt.axis('equal')
plt.show()

fig, ax = plt.subplots(figsize=(15, 15), dpi = 200)
#plt.figure(figsize=(15,15), dpi=200)
for e in small_g2.es:
    start = e.source
    end = e.target
    cur_edge = sorted([start,end])

    v1 = small_g2.vs[e.source]['coordinates']
    v2 = small_g2.vs[e.target]['coordinates']
    data = np.vstack([v1, v2])
    x = data[:, 0]
    y = data[:, 1]
    #if cur_edge in new_time_edges:
    #    print(cur_edge)
        #print(v1, v2)
    #    plt.plot(x,y,'#FF0000')#, linewidth = 4)
    #else:
    plt.plot(x, y, '#8ab4f7')


ax.imshow(map_img, zorder = 0, extent = BBox, aspect = 'equal')
plt.axis('equal')
plt.show()

l = 75
r = 50
s = 50

def movement(graph, orig, inter, neigh):
  if (orig == neigh):
    return 75
  elif orig == None:
    return 0
  orig_coords = graph.vs[orig]['coordinates']
  inter_coords = graph.vs[inter]['coordinates']
  neigh_coords = graph.vs[neigh]['coordinates']
  dy1 = orig_coords[1] - inter_coords[1]
  dx1 = orig_coords[0] - inter_coords[0]
  if dx1 == 0:
    dx1 = 0.00001
  start_slope = dy1/dx1 #(orig_coords[1]-inter_coords[1])/(orig_coords[0]-inter_coords[0])
  dy2 = inter_coords[1] - neigh_coords[1]
  dx2 = inter_coords[0] - neigh_coords[0]
  if dx2 == 0:
    dx2 = 0.00001
  next_slope = dy2/dx2 #(inter_coords[1]-neigh_coords[1])/(inter_coords[0] - neigh_coords[0])
  l_thresh = start_slope - (1/4)
  r_thresh = start_slope + (1/4)
  reverse = start_slope*-1

  if next_slope < l_thresh and next_slope > reverse:
    return 75
  else:
    return 50

def modified_dijkstra(graph, start, no_restr):
  unvisited = graph.vs.indices
  sp = []
  prev = []
  pred = None
  for un in unvisited:
    sp.append(np.inf)
    prev.append(np.inf)
  sp[start] = 0
  while len(unvisited) > 0:
    cur_min_node = None
    for un in unvisited:
      #neighs = graph.neighbors(un)
      if cur_min_node == None:
        cur_min_node = un
      elif sp[un] < sp[cur_min_node]:
        cur_min_node = un
    neighs = graph.neighbors(cur_min_node)
    for ng in neighs:
      if ng in unvisited:
        temp = sp[cur_min_node] + graph.es[graph.get_eid(cur_min_node, ng)]['weight'] + (no_restr * movement(graph, pred, cur_min_node, ng))
        if temp < sp[ng]:
          sp[ng] = temp
          prev[ng] = cur_min_node
          pred = cur_min_node
    unvisited.remove(cur_min_node)
  return prev, sp

#delete
test = [1, 2, 3, 4, 5]
test2 = [2, 4, 6, 9, 1]
test3 = np.intersect1d(test, test2)
print(test3)

common_nodes = np.intersect1d(small_g.vs.indices, small_g2.vs.indices)
print(len(common_nodes), len(small_g.vs.indices), len(small_g2.vs.indices))

test = np.random.choice(common_nodes, 5)
for t in test:
  print(small_g2.vs[t])

print(small_g2.es[1])

for t in test:
  test1, test2 = modified_dijkstra(small_g2, t, 1)
  print(test1)
  print(test2)

print(len(test1))
print((test2))

def reverse_paths(prev, start, end):
  rp = []
  n = end
  while n != start:
    rp.append(n)
    n = prev[n]
  rp.append(start)
  return rp

test3 = reverse_paths(test1, 93, 142)
print(test3)

longitude = []
latitude = []
for t3 in test3:
  x = small_g2.vs[t3]['coordinates'][0]
  y = small_g2.vs[t3]['coordinates'][1]
  longitude.append(x)
  latitude.append(y)

fig, ax = plt.subplots(figsize=(9,9))
ax.plot(longitude, latitude, marker = 'o', markersize = 2)

source_idx = 93
dest_idx = 142

v1 = small_g2.vs[source_idx]['coordinates']
v2 = small_g2.vs[dest_idx]['coordinates']
#print(v1, v2)

#data2 = np.vstack([v1, v2])
#x2 = data2[:, 0]
#y2 = data2[:, 1]

#plt.plot(x2, y2, 'ro')

plt.plot(v1[0], v1[1], 'go')

plt.plot(v2[0], v2[1], 'ro')

ax.set_xlim(BBox[0], BBox[1])
ax.set_ylim(BBox[2], BBox[3])

ax.imshow(map_img, zorder = 0, extent = BBox, aspect = 'equal')
plt.show()