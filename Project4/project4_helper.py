# -*- coding: utf-8 -*-
"""Project4_Helper.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1g3QStziwTbWxapqYQtesCjmm8ISFhVjz
"""

!pip install 'igraph'
#!pip install 'cairocffi'
#!pip install 'pycairo'

from igraph import *
import json
import random
import numpy as np
from numpy import linalg
import itertools
import matplotlib.pyplot as plt
from scipy.spatial import Delaunay  # needed for triangulation
import os
import pandas as pd
from copy import deepcopy
import networkx as nx
from geopy.geocoders import Nominatim
import math
#import cairocffi

random.seed(2022)
np.random.seed(2022)

with open('los_angeles_censustracts.json') as f:
    census_tracts = json.loads(f.readline())

census_tracts['features'][0]['properties']

np.array(census_tracts['features'][0]['geometry']['coordinates'][0]).mean(axis=0)  # [longitude, latitude]

display_names = dict()
coordinates = dict()

for area in census_tracts['features']:
    id = int(area['properties']['MOVEMENT_ID'])
    display_name = area['properties']['DISPLAY_NAME']
    display_names[id] = display_name
    a = area['geometry']['coordinates'][0]
    coordinates[id] = np.array(a if type(a[0][0]) == float else a[0]).mean(axis=0)

for i in range(5):
    key = i + 1
    print('{}: {}, {}'.format(key, display_names[key], coordinates[key]))

#9
g = Graph(directed=False)
g.add_vertices(len(display_names))
g.vs['display_name'] = list(display_names.values())  # index = id - 1
g.vs['coordinates'] = list(coordinates.values())

month_filter = {12}  # for monthly aggregate data of 4th quarter, we can filter data based off of only December

edges = []
weights = []

with open('los_angeles-censustracts-2019-4-All-MonthlyAggregate.csv') as f:
    f.readline()  # skip the first line

    while True:
        line = f.readline()
        if line == '':
            break  # end of file

        vals = line.strip().split(',')

        # read edge info
        src, dest, month, dist = int(vals[0]), int(vals[1]), int(vals[2]), float(vals[3])

        # if data is not relevant, skip it
        if month not in month_filter:
            continue

        edges.append((src - 1, dest - 1))
        weights.append(dist)

g.add_edges(edges)
g.es['weight'] = weights
del edges, weights

print(len(g.vs), len(g.es))

# keep only the giant connected component
components = g.components()
gcc = max(components, key=len)
vs_to_delete = [i for i in range(len(g.vs)) if i not in gcc]
g.delete_vertices(vs_to_delete)

# remove duplicate edges
g = g.simplify(combine_edges=dict(weight='mean'))  # combine duplicate edges

print(len(g.vs), len(g.es))

#10
mst = g.spanning_tree(weights=g.es['weight'])

edf = mst.get_edge_dataframe()
edf.head()

import matplotlib.pyplot as plt
weights = mst.es['weight']
binwidth = 20
bins = np.arange(min(weights), max(weights) + binwidth, binwidth)
plt.hist(weights, bins=bins)
plt.show()

edge_selection = [0, 500, 1000, 1500, 2000, 2647]
j = 0
for i, e in enumerate(mst.es):
  if i == edge_selection[j]:
    print('Start coordinates: ', mst.vs[e.source]['display_name'], " ", mst.vs[e.source]['coordinates'], " and end coordinates: ", mst.vs[e.target]['display_name'], " ", mst.vs[e.target]['coordinates'])
    print('Distance in miles: {:.3f}\nTime taken: {:.1f}\n---------\n'.format(linalg.norm(mst.vs[e.source]['coordinates'] - mst.vs[e.target]['coordinates'])* 69, e['weight']))
    j += 1

"""First edge goes from 823 E Grand Ave, Alhambra, CA 91801 to 300 N 3rd St, Alhambra, CA 91801.

The second edge goes from 3926 139th St, Hawthorne, CA 90250 to 13130 Florwood Ave, Hawthorne, CA 90250.

The third edge goes from 12310 Sylvan St, North Hollywood, CA 91606 to 6240 Vantage Ave, North Hollywood, CA 91606.

The fourth edge goes from 2302 S Gramercy Pl, Los Angeles, CA 90018 to 2069 S Oxford Ave, Los Angeles, CA 90018

The fifth edge goes from 5302 Lemoran Ave, Pico Rivera, CA 90660 to 6325 Pioneer Blvd, Whittier, CA 90606.

The sixth edge goes from 9862 Ramm Dr, Anaheim, CA 92804 to 9671 W Colchester Dr, Anaheim, CA 92804
"""

###########################################################

#delete
test = (g.es.select(_source=1, _target=2))
test2 = g.es[g.get_eid(1, 2)]
print(test['weight'])
print(test2['weight'])

#delete
test = mst.to_networkx()
test2 = test.edges.data()

#11
def is_triangle(sides):
    #write code here
  if (sides[0] + sides[1]) >= sides[2] and (sides[1] + sides[2]) >= sides[0] and (sides[2] + sides[0]) >= sides[1]:
    return True
  else:
    return False

print('Test:', is_triangle([1,4,2]), is_triangle([3,5,3]))

#delete
test = (random.sample(g.vs.indices, 3))
test2 = []
test3 = random.sample(g.vs.indices, 3)
test2.append(test)
test2.append(test3)
print(test2)

def sample_triangles(g, n_samples):
  result = []
  while len(result) < n_samples:
    random_node = random.sample(population = g.vs.indices, k = 3)
    if g.are_connected(random_node[0], random_node[1]) and g.are_connected(random_node[1], random_node[2]) and g.are_connected(random_node[2], random_node[0]):
      random_node.sort()
      if random_node in result:
        continue
      else:
        result.append(random_node)
    #result = list()
    #result will have tuple of the the vertices of a triangle
  return result

n_samples = 1000  # WARNING: this might take a minute for larger sample sizes
triangles = 0
sampled = sample_triangles(g, n_samples)

for triangle_vs in sampled:

    edge_lengths = []

    for i in range(3):
        for j in range(i):
            edge_lengths.append(min(g.es.select(_between=([triangle_vs[i]], [triangle_vs[j]]))['weight']))
    #print(edge_lengths)
    triangles += is_triangle(edge_lengths)

print('Triangle inequality holds by {}%'.format(round(100.0 * triangles / n_samples, 1)))

#delete
print(len(sampled))

"""1. find the minimum spanning tree T under [d_ij]
2. create a multigraph G by using two copies of each edge of T
3. find an eulerian walk of G and an embedded tour
    eulerian walk - visits every node at least once and each edge exactly once

"""

#12
nx_mst = mst.to_networkx()
multi_graph = nx.MultiGraph()
mst_cost = 0
for e in nx_mst.edges:
  wght = nx_mst.edges[e[0],e[1]]['weight']
  mst_cost += wght
  multi_graph.add_edge(e[0],e[1],weight=wght)
  multi_graph.add_edge(e[0], e[1], weight=wght)

sources = []
#count = 0
for i, nd in enumerate(multi_graph.nodes):
  sources.append(nd)
  if i >= 50:
    break

euler_paths = []
for i in sources:
  euler_path = list(nx.eulerian_circuit(multi_graph, source = i))
  euler_paths.append(euler_path)

#euler_list = list(euler_path)
#print(len(euler_list))
node_paths = []
for p in euler_paths:
  node_path = []
  for el in p: #euler_list:
    node_i = el[0]
    if node_i not in node_path:
      node_path.append(node_i)
  node_path.append(p[0][0]) #euler_list[0][0])
  node_paths.append(node_path)

cost_flag = 1000000
best_path = []
counter = 0
nx_gcc = g.to_networkx()
for n_p in node_paths:
  appr_cost = 0
  wght = 0
  print(counter)
  counter+=1
  for n in n_p: #node_path:
    if n == n_p[0]: #node_path[0]:
      n_1 = n
    else:
      if nx_mst.has_edge(n_1, n):
        wght = nx_mst.edges[n_1, n]['weight']
        n_1 = n
      else:
        wght = nx.dijkstra_path_length(nx_gcc, n_1, n)
        n_1 = n
      appr_cost += wght
  if appr_cost < cost_flag:
    cost_flag = appr_cost
    best_path = n_p

print(mst_cost)
#print(appr_cost)
#print(appr_cost/mst_cost)
print(cost_flag)
print(cost_flag/mst_cost)

#delete
#geo test for 13
geolocator = Nominatim(user_agent="geo_test")
location = geolocator.reverse("34.10309557, -118.12053321")
print(location.address)
test = mst.vs[0]
print(mst.vs[0]['coordinates'][0])
print(nx_mst.nodes[0]['coordinates'][0])

#13
longitude = []
latitude = []
for nd in best_path:
  x = nx_mst.nodes[nd]['coordinates'][0]
  y = nx_mst.nodes[nd]['coordinates'][1]
  longitude.append(x)
  latitude.append(y)

BBox = (-118.73, -117.75, 33.65, 34.43)
map_img = plt.imread('map2.PNG')

fig, ax = plt.subplots(figsize=(10, 9))
ax.plot(longitude, latitude, marker = 'o', markersize = 2)
#ax.scatter(longitude, latitude)

ax.set_xlim(BBox[0], BBox[1])
ax.set_ylim(BBox[2], BBox[3])

ax.imshow(map_img, zorder=0, extent = BBox, aspect = 'equal')

plt.show()

#delete
test = coordinates[1]
print(test[0])
longitude = []
latitude = []
for i in range(1, len(coordinates)):
  x = coordinates[i][0]
  y = coordinates[i][1]
  longitude.append(x)
  latitude.append(y)
print(max(longitude))
print(max(latitude))
print(min(longitude))
print(min(latitude))

#delete
test = (euler_list[5])
print(test)
print(test[0])
print(euler_list[5][0])
print(multi_graph.get_edge_data(8, 5)[0]['weight'])
print(len(node_path))
print(nx_mst.edges[8, 5]['weight'])
test = (g.vs['coordinates'])
test = tes

####################################################################

full_lat = []
full_long = []
for xy in g.vs['coordinates']:
  full_long.append(xy[0])
  full_lat.append(xy[1])

tri = Delaunay(g.vs['coordinates']) #use the Delaunay function imported above

BBox = (-118.73, -117.75, 33.65, 34.43)
map_img = plt.imread('map2.PNG')

fig, ax = plt.subplots(figsize=(10, 9))
#ax.plot(full_long, full_lat, marker = 'o', markersize = 2)
#ax.scatter(longitude, latitude)
plt.triplot(full_long, full_lat, tri.simplices.copy())   #coordinates[:, 0], coordinates[:, 1], tri.simplices.copy())

ax.set_xlim(BBox[0], BBox[1])
ax.set_ylim(BBox[2], BBox[3])

ax.imshow(map_img, zorder=0, extent = BBox, aspect = 'equal')

plt.show()

#delete
BBox = (-118.73, -117.75, 33.65, 34.43)
map_img = plt.imread('map2.PNG')

plt.figure(figsize=(15,15))
plt.triplot(full_long, full_lat, tri.simplices.copy())   #coordinates[:, 0], coordinates[:, 1], tri.simplices.copy())
plt.show()

#delete
test = (1, 2)
empty_l = []
test2 = (4, 5)
empty_l.append(test)
empty_l.append(test2)
print(empty_l)
print(len(tri.simplices))

edges_to_induce = []

for i in range(tri.simplices.shape[0]):
    for col1, col2 in ((0, 1), (1, 2), (0, 2)):
        temp = (tri.simplices[i][col1], tri.simplices[i][col2])
        sorted(temp)
        if temp in edges_to_induce:
          continue
        else:
          if g.are_connected(temp[0], temp[1]):
            edges_to_induce.append(temp)
        #add the edges to edges_to_induce

tri_g = g.subgraph_edges(edges_to_induce)

#delete
print(tri_g.es[g.get_eid(1,2)]['weight'])

############################

def max_flow(gr, source_id, target_id):
  s_coords = gr.vs[source_id]['coordinates']
  t_coords = gr.vs[target_id]['coordinates']
  dist = math.sqrt((s_coords[0]-t_coords[0])**2 + (s_coords[1]-t_coords[1])**2)
  m_dist = dist*69
  w = gr.es[gr.get_eid(source_id, target_id)]['weight']
  speed = (m_dist/w)/3600
  car_length = 0.003
  safety_distance = speed * (2/3600)
  cars_per_mile = (m_dist+safety_distance)/(car_length + safety_distance)
  n_lanes = 2
  cars_per_hour = cars_per_mile * m_dist * 2 / (w/3600)
  return cars_per_hour

#delete
test = max_flow(tri_g, 1, 2)
print(test)
sc = tri_g.vs[1]['coordinates']
tc = tri_g.vs[2]['coordinates']
d = math.sqrt((sc[0]-tc[0])**2 + (sc[1]-tc[1])**2)
md = d*69
ww = tri_g.es[tri_g.get_eid(1, 2)]['weight']
s = (md/ww)/3600
cl = 0.003
sd = s*(2/3600)
cpm = (md + sd)/(cl + sd)
nl = 2
cph = cpm * md * 2 /(ww/3600)
print(cph)

cars_per_hour = []
for e in tri_g.es:
  cph = max_flow(tri_g, e.source, e.target)
  cars_per_hour.append(cph)

tri_g.es['capacity'] = cars_per_hour

total_flow = 0
for e in tri_g.es:
  total_flow += e['capacity']
print(total_flow)
print(len(tri_g.es))

#########################

#16
source_coordinates = [-118.5670548, 34.0458901]  # malibu
dest_coordinates = [-118.1819374, 33.759958]  # long beach

malibu_smallest = 100000
long_smallest = 10000

mal_id = 0
lb_id = 0

for v in tri_g.vs:
  m = math.sqrt((source_coordinates[0] - v['coordinates'][0])**2 + (source_coordinates[1] - v['coordinates'][1])**2)
  if m < malibu_smallest:
    malibu_smallest = m
    mal_id = v.index
  lb = math.sqrt((dest_coordinates[0] - v['coordinates'][0])**2 + (dest_coordinates[1] - v['coordinates'][1])**2)
  if lb < long_smallest:
    long_smallest = lb
    lb_id = v.index

print(malibu_smallest)
print(long_smallest)
print(mal_id)
print(lb_id)

nx_tri_g = tri_g.to_networkx()
dj_paths = list(nx.edge_disjoint_paths(nx_tri_g, mal_id, lb_id))

total_max_flow = 0
for p in dj_paths:
  max_f = 0
  for i in range(len(p)-1):
    n = p[i]
    n_1 = p[i+1]
    max_f += max_flow(tri_g, n, n_1)
  print("The path ", p, " has a max flow of ", max_f, " cars per hour.")
  total_max_flow += max_f

print(len(dj_paths))

print(nx_tri_g.degree(1511))
print(nx_tri_g.degree(663))

#17
trim_thresh = 800

edges_to_induce = tri_g.es.select(weight_le=trim_thresh)
tri_g_trimmed = tri_g.subgraph_edges(edges_to_induce)

# plot the roads
fig, ax = plt.subplots(figsize=(15, 15), dpi = 200)
#plt.figure(figsize=(15,15), dpi=200)
for e in tri_g.es:
    v1 = tri_g.vs[e.source]['coordinates']
    v2 = tri_g.vs[e.target]['coordinates']
    data = np.vstack([v1, v2])
    x = data[:, 0]
    y = data[:, 1]
    plt.plot(x, y, '#8ab4f7' if e['weight'] < trim_thresh else '#fc9c3c')

# mark the source and destination
# source = tri_g.vs.select(display_name=source_address)[0].index
# target = tri_g.vs.select(display_name=dest_address)[0].index
# v1 = tri_g.vs[source_idx]['coordinates']
# v2 = tri_g.vs[dest_idx]['coordinates']
# data = np.vstack([v1, v2])
# x = data[:, 0]
# y = data[:, 1]
# plt.plot(x, y, 'bo')
ax.imshow(map_img, zorder = 0, extent = BBox, aspect = 'equal')

plt.axis('equal')
plt.show()

nx_test = tri_g_trimmed.to_networkx()
dj_test = list(nx.edge_disjoint_paths(nx_test, mal_id, lb_id))
print(len(dj_test))
print(len(tri_g.es()))
print(len(tri_g_trimmed.es()))
print()

#18
nx_tri_g_trimmed = tri_g_trimmed.to_networkx()
dj_trimmed_paths = list(nx.edge_disjoint_paths(nx_tri_g_trimmed, mal_id, lb_id))

total_max_flow_trimmed = 0
for pt in dj_trimmed_paths:
  max_f = 0
  for i in range(len(pt)-1):
    n = pt[i]
    n_1 = pt[i+1]
    max_f += max_flow(tri_g_trimmed, n, n_1)
  print("The path ", pt, " has a max flow of ", max_f, " cars per hour.")
  total_max_flow_trimmed += max_f

print(len(dj_trimmed_paths))

print(total_max_flow_trimmed)
print(nx_tri_g_trimmed.degree(1511))
print(nx_tri_g_trimmed.degree(663))

path_edges = []
for i in dj_trimmed_paths:
  for j in i:
    if j == i[0]:
      start_node = j
    else:
      temp = (start_node, j)
      start_node = j
      path_edges.append(temp)
#print(test)

path_only_g = tri_g_trimmed.subgraph_edges(path_edges)

fig, ax = plt.subplots(figsize=(15, 15), dpi = 200)
#plt.figure(figsize=(15,15), dpi=200)
for e in path_only_g.es:
    v1 = path_only_g.vs[e.source]['coordinates']
    v2 = path_only_g.vs[e.target]['coordinates']
    data = np.vstack([v1, v2])
    x = data[:, 0]
    y = data[:, 1]
    plt.plot(x, y, '#fff900' if e['weight'] < trim_thresh else '#fc9c3c')

# mark the source and destination
source_idx = mal_id
dest_idx = lb_id
# source = tri_g.vs.select(display_name=source_address)[0].index
# target = tri_g.vs.select(display_name=dest_address)[0].index
v1 = tri_g.vs[source_idx]['coordinates']
v2 = tri_g.vs[dest_idx]['coordinates']
data = np.vstack([v1, v2])
x = data[:, 0]
y = data[:, 1]
plt.plot(x, y, 'bo')
ax.imshow(map_img, zorder = 0, extent = BBox, aspect = 'equal')

plt.axis('equal')
plt.show()

#print(list(nx_tri_g.neighbors(1700)))
#print(nx_tri_g.number_of_edges(1511, 1700))
old_paths = []
for i in dj_paths:
  for j in i:
    if j == i[0]:
      start_node = j
    else:
      temp = (start_node, j)
      start_node = j
      old_paths.append(temp)
print(old_paths)

old_g = tri_g.subgraph_edges(old_paths)
# plot the roads
fig, ax = plt.subplots(figsize=(15, 15), dpi = 200)
#plt.figure(figsize=(15,15), dpi=200)
for e in old_g.es:
    v1 = old_g.vs[e.source]['coordinates']
    v2 = old_g.vs[e.target]['coordinates']
    data = np.vstack([v1, v2])
    x = data[:, 0]
    y = data[:, 1]
    plt.plot(x, y, '#fff900' if e['weight'] < trim_thresh else '#fc9c3c')

# mark the source and destination
source_idx = mal_id
dest_idx = lb_id
# source = tri_g.vs.select(display_name=source_address)[0].index
# target = tri_g.vs.select(display_name=dest_address)[0].index
v1 = tri_g.vs[source_idx]['coordinates']
v2 = tri_g.vs[dest_idx]['coordinates']
data = np.vstack([v1, v2])
x = data[:, 0]
y = data[:, 1]
plt.plot(x, y, 'bo')
ax.imshow(map_img, zorder = 0, extent = BBox, aspect = 'equal')

plt.axis('equal')
plt.show()

#19
road_map = deepcopy(tri_g_trimmed)
len(road_map.vs), len(road_map.es)

print(road_map.vs[0].index)
test = road_map.to_networkx()
test2 = nx.single_source_dijkstra(test, 0, 1, weight='geo_distance')
print(test2[0])

edge_ends = np.array([[e.source, e.target] for e in road_map.es])
sources, targets = edge_ends[:, 0], edge_ends[:, 1]
distances = []
for e in road_map.es:
  s_n = road_map.vs[e.source]['coordinates']
  d_n = road_map.vs[e.target]['coordinates']
  a = s_n[0]-d_n[0]
  b = s_n[1]-d_n[1]
  c = math.sqrt(a**2 + b**2)
  distances.append(c)
#distances = #write here

road_map.es['geo_distance'] = distances
vcount = len(road_map.vs)
max(distances)

#delete
print(len(road_map.vs.indices))
print(road_map.vs[0].index)
print((road_map.neighbors(0)))

#delete
test = road_map.get_shortest_paths(source = road_map.vs.indices, target = road_map.vs.indices, weights = road_map.es['geo_distance'])

def bellman_ford(graph, source):
  dist, pred = dict(), dict()

  for v in graph.vs.indices:
    dist[v], pred[v] = float('inf'), None
  dist[source] = 0

  for _ in range(len(graph.es)-1):
    for v2 in graph.vs.indices:
      for neigh in graph.neighbors(v2):
        if dist[neigh] > dist[v2] + graph.es[graph.get_eid(v2, neigh)]['geo_distance']:
          dist[neigh], pred[neigh] = dist[v2] + graph.es[graph.get_eid(v2, neigh)]['geo_distance'], v2

  return dist, pred

#delete
#print(len(test))
test_paths = []
for i in dj_trimmed_paths:
  for j in i:
    if j == i[0]:
      start_node = j
    else:
      temp = (start_node, j)
      start_node = j
      test_paths.append(temp)
print(test_paths)
test_g = road_map.subgraph_edges(test_paths)
test = bellman_ford(test_g, 1)

print(test)

shortest_path_distance = []
rm_nodes = road_map.vs
nx_road_map = road_map.to_networkx()
for v in range(len(rm_nodes)):
  bellman_dists = bellman_ford(road_map, rm_nodes[v].index)
  #start_node = rm_nodes[v].index
  print(v)
  #for v2 in range(v+1, len(rm_nodes)):
  #  short_path = 0
  #  end_node = rm_nodes[v2].index
  #  if road_map.are_connected(start_node, end_node):
  ##    #print("connected")
   #   short_path = road_map.es[road_map.get_eid(start_node, end_node)]['geo_distance']
  #  else:
  #    temp = road_map.get_shortest_paths(start_node, to=end_node, weights = road_map.es['geo_distance'], output = "epath")
  #    for e in temp[0]:
  #      short_path += road_map.es[e]['geo_distance']
  #    #short_path = nx.single_source_dijkstra(G = nx_road_map, source = start_node, target = end_node, weight='geo_distance')[0]
  shortest_path_distance.append(bellman_dists)
#write here
shortest_path_distance = np.array(shortest_path_distance)
shortest_path_distance.shape

shortest_path_distance = []
shortest_path_time = []
rm_nodes = road_map.vs
nx_road_map = road_map.to_networkx()
for v in range(len(rm_nodes)-1):
  start_node = rm_nodes[v].index
  print(v)
  for v2 in range(v+1, len(rm_nodes)):
    short_path = 0
    short_time = 0
    end_node = rm_nodes[v2].index
    if road_map.are_connected(start_node, end_node):
      #print("connected")
      short_path = road_map.es[road_map.get_eid(start_node, end_node)]['geo_distance']
      short_time = road_map.es[road_map.get_eid(start_node, end_node)]['weight']
    else:
      temp = road_map.get_shortest_paths(start_node, to=end_node, weights = road_map.es['geo_distance'], output = "epath")
      temp2 = road_map.get_shortest_paths(start_node, to=end_node, weights = road_map.es['weight'], output = "epath")
      for e in temp[0]:
        short_path += road_map.es[e]['geo_distance']
      for e2 in temp2[0]:
        short_time += road_map.es[e2]['weight']
      #short_path = nx.single_source_dijkstra(G = nx_road_map, source = start_node, target = end_node, weight='geo_distance')[0]
    shortest_path_distance.append(short_path)
    shortest_path_time.append(short_time)
#write here
shortest_path_distance = np.array(shortest_path_distance)
shortest_path_time = np.array(shortest_path_time)
shortest_path_distance.shape

print(shortest_path_distance[0])

actual_geo_distances = np.zeros((vcount,vcount))
differences = np.zeros((vcount, vcount))
iter = 0
for v in range(len(rm_nodes)-1):
  start_node = rm_nodes[v].index
  for v2 in range(v+1, len(rm_nodes)):
    end_node = rm_nodes[v2].index
    if road_map.are_connected(start_node, end_node):
      actual_geo = shortest_path_distance[iter] #road_map[road_map.get_eid(start_node, end_node)]['geo_distance']
    else:
      a = rm_nodes[v]['coordinates']
      b = rm_nodes[v2]['coordinates']
      actual_geo = math.sqrt((a[0] - b[0])**2 + (a[1]-b[1])**2)
    dif = shortest_path_distance[iter] - actual_geo
    actual_geo_distances[v][v2] = actual_geo
    differences[v][v2] = dif
    iter+=1
#actual_geo_distances = None
#differences = None

#delete
flat_difs = differences.flatten()
sort_flat = flat_difs.argsort()
print(sort_flat[-20:])
print(flat_difs[sort_flat[-20:]])
print(flat_difs[flat_difs.argmax()])
print(sort_flat[-2:-1][0])

#delete
test = 1040043%2646
print(test)
print(1040043/2646)
print(differences[165][393])
print(np.unravel_index([1040043], (2647, 2647)))
test2 = list(np.unravel_index([1040043], (2647, 2647)))
print(test2[0], test2[1])
print(differences[392][2419])

n = 20
flat_difs = differences.flatten()
sort_flat_indices = flat_difs.argsort()
max_indices = sort_flat_indices[-20:]
matrix_indices = np.unravel_index(max_indices, (2647, 2647))
matrix_indices = list(matrix_indices)
#print(matrix_indices[0][19])

ind = #argsort differences to get max value

new_static_edges = []
for i in range(20): #40 because there will be repititions (A-> B is same as B-> A)
    newedge = [matrix_indices[0][i], matrix_indices[1][i]]
    print("New edge nodes: ", newedge, " and the difference: ", differences[matrix_indices[0][i]][matrix_indices[1][i]])#new edge nodes and the difference )
    new_static_edges.append(newedge)

#add the new_static_edges to our graph.

road_map_static = deepcopy(tri_g_trimmed) #ensure to use deepcopy
for edg in new_static_edges:
    start = edg[0]
    end = edg[1]
    dist = actual_geo_distances[start][end]# which distance to use?
    road_map_static.add_edge(start, end, weight = dist)

# plot the roads and highlight our new edges.
fig, ax = plt.subplots(figsize=(15, 15), dpi = 200)
#plt.figure(figsize=(15,15), dpi=200)
for e in road_map_static.es:
    start = e.source
    end = e.target
    cur_edge = sorted([start,end])

    v1 = road_map_static.vs[e.source]['coordinates']
    v2 = road_map_static.vs[e.target]['coordinates']
    data = np.vstack([v1, v2])
    x = data[:, 0]
    y = data[:, 1]
    if cur_edge in new_static_edges:
        print(cur_edge)
        plt.plot(x,y,'#FF0000')
    else:
        plt.plot(x, y, '#8ab4f7')

# mark the source and destination
# source = tri_g.vs.select(display_name=source_address)[0].index
# target = tri_g.vs.select(display_name=dest_address)[0].index
# v1 = road_map_static.vs[source_idx]['coordinates']
# v2 = road_map_static.vs[dest_idx]['coordinates']
# data = np.vstack([v1, v2])
# x = data[:, 0]
# y = data[:, 1]
# plt.plot(x, y, 'bo')


ax.imshow(map_img, zorder = 0, extent = BBox, aspect = 'equal')
plt.axis('equal')
plt.show()

# A, B >1000, freq:10 ->10,000
#C, D = 500 , 10,000 - > 500*10,000

#20
np.random.seed(2022)
frequencies = np.random.randint(1,1001, (vcount,vcount) )
frequencies.shape

difference_frequency = np.multiply(differences,frequencies)

n = 20
flat_weighted_difs = difference_frequency.flatten()
sort_flat_weigh_indices = flat_weighted_difs.argsort()
max_weigh_indices = sort_flat_weigh_indices[-20:]
matrix_weigh_indices = np.unravel_index(max_weigh_indices, (2647, 2647))
matrix_weigh_indices = list(matrix_weigh_indices)

#ind = #argsort differences to get max value

weigh_static_edges = []
for i in range(20): #40 because there will be repititions (A-> B is same as B-> A)
    newedge = [matrix_weigh_indices[0][i], matrix_weigh_indices[1][i]]
    print("New edge nodes: ", newedge, " and the difference: ", difference_frequency[matrix_weigh_indices[0][i]][matrix_weigh_indices[1][i]])#new edge nodes and the difference )
    weigh_static_edges.append(newedge)

road_map_weigh = deepcopy(tri_g_trimmed) #ensure to use deepcopy
for edg in weigh_static_edges:
    start = edg[0]
    end = edg[1]
    dist = actual_geo_distances[start][end]# which distance to use?
    road_map_weigh.add_edge(start, end, weight = dist)

# plot the roads and highlight our new edges.
fig, ax = plt.subplots(figsize=(15, 15), dpi = 200)
#plt.figure(figsize=(15,15), dpi=200)
for e in road_map_weigh.es:
    start = e.source
    end = e.target
    cur_edge = sorted([start,end])

    v1 = road_map_weigh.vs[e.source]['coordinates']
    v2 = road_map_weigh.vs[e.target]['coordinates']
    data = np.vstack([v1, v2])
    x = data[:, 0]
    y = data[:, 1]
    if cur_edge in weigh_static_edges:
        print(cur_edge)
        plt.plot(x,y,'#FF0000')
    else:
        plt.plot(x, y, '#8ab4f7')

# mark the source and destination
# source = tri_g.vs.select(display_name=source_address)[0].index
# target = tri_g.vs.select(display_name=dest_address)[0].index
# v1 = road_map_static.vs[source_idx]['coordinates']
# v2 = road_map_static.vs[dest_idx]['coordinates']
# data = np.vstack([v1, v2])
# x = data[:, 0]
# y = data[:, 1]
# plt.plot(x, y, 'bo')


ax.imshow(map_img, zorder = 0, extent = BBox, aspect = 'equal')
plt.axis('equal')
plt.show()

#21
road_map_dynamic = deepcopy(road_map)
budget = 20
new_dynamic_edges = []
#for i in range(budget):
    #dynamic_short_paths = road_map_dynamic.shortest_paths(weights=road_map_dynamic.es['geo_distance'])
    #get current graph shortest paths
    #get differences
    #sort differences and pich the highest
    # get vertices of new edge to build. Build the edge and print its vertices.
    #new_egde = None
    #print(new_Edge, difference_between_new_edge_vertices  )
    #new_dynamic_edges.append(new_edge )

    #add the new edge
    ##new_distance = #Get this
    #road_map_dynamic.add_edge(start, end, weight = -1 , geo_distance = new_distance)

max_edge = [4722017]
max_edge_indices = list(np.unravel_index(max_edge, (2647, 2647)))
new_dynamic_edges.append((max_edge_indices[0][0], max_edge_indices[1][0]))
#print(max_edge_indices, flat_difs[max_edge])
#print(max_edge_indices[0][0], max_edge_indices[1][0])
road_map_dynamic.add_edge(max_edge_indices[0][0], max_edge_indices[1][0], weight = -1, geo_distance = actual_geo_distances[max_edge_indices[0][0]][max_edge_indices[1][0]])

#delete
#print(np.argwhere(flat_difs>= 0.11337999))
#print(np.argmax(flat_difs))
new_dynamic_edges = [[1783, 2416], [2140, 2419], [986, 1510], [49, 2419], [285, 2419], [1717, 2419], [1783, 2417], [1956, 2419], [2247, 2419], [1005, 1678], [2414, 2619], [121, 689], [2242, 2419], [1699, 1781], [144, 2619], [2402, 2416], [144, 2040], [1700, 1782], [356, 1679], [2414, 2559]]
for edg in new_dynamic_edges:
  start = edg[0]
  end = edg[1]
  dist = actual_geo_distances[start][end]
  road_map_dynamic.add_edge(start, end, weight = -1, geo_distance = dist)

dynamic_diffs = np.zeros((vcount, vcount))
dynamic_geo_dist = np.zeros((vcount, vcount))
#shortest_dynamic_path_distance = []
rmd_nodes = road_map_dynamic.vs
iter = 0
#nx_road_map = road_map.to_networkx()
for v in range(len(rmd_nodes)-1):
  start_node = rmd_nodes[v].index
  print(v)
  for v2 in range(v+1, len(rmd_nodes)):
    short_path = 0
    end_node = rmd_nodes[v2].index
    if road_map_dynamic.are_connected(start_node, end_node):
      #print("connected")
      #dyn_geo = shortest_dynamic_path_distance[iter] #road_map[road_map.get_eid(start_node, end_node)]['geo_distance']
      short_path = road_map_dynamic.es[road_map_dynamic.get_eid(start_node, end_node)]['geo_distance']
      dyn_geo = short_path
    else:
      temp = road_map_dynamic.get_shortest_paths(start_node, to=end_node, weights = road_map_dynamic.es['geo_distance'], output = "epath")
      for e in temp[0]:
        short_path += road_map_dynamic.es[e]['geo_distance']
      a = rmd_nodes[v]['coordinates']
      b = rmd_nodes[v2]['coordinates']
      dyn_geo = math.sqrt((a[0] - b[0])**2 + (a[1]-b[1])**2)
    #shortest_dynamic_path_distance.append(short_path)
    d_dif = short_path - dyn_geo #shortest_dynamic_path_distance[iter] - dyn_geo
    dynamic_geo_dist[v][v2] = dyn_geo
    dynamic_diffs[v][v2] = d_dif
    #iter+=1
      #short_path = nx.single_source_dijkstra(G = nx_road_map, source = start_node, target = end_node, weight='geo_distance')[0]

#write here
#shortest_dynamic_path_distance = np.array(shortest_dynamic_path_distance)
#shortest_dynamic_path_distance.shape
#n = 20
flat_d_difs = dynamic_diffs.flatten()
sort_d_flat_indices = flat_d_difs.argsort()
max_dyn_indices = sort_d_flat_indices[-1:]
matrix_dyn_indices = np.unravel_index(max_dyn_indices, (2647, 2647))
matrix_dyn_indices = list(matrix_dyn_indices)
new_dynamic_edges.append([matrix_dyn_indices[0][0], matrix_dyn_indices[1][0]])
road_map_dynamic.add_edge(matrix_dyn_indices[0][0], matrix_dyn_indices[1][0], weight = -1, geo_distance = actual_geo_distances[matrix_dyn_indices[0][0]][matrix_dyn_indices[1][0]])
print(matrix_dyn_indices)

print(new_dynamic_edges)
#[(1783, 2416), (2140, 2419), (986, 1510), (49, 2419), (285, 2419), (1717, 2419), (1783, 2417), (1956, 2419), (2247, 2419), (1005, 1678), (2414, 2619), (121, 689), (2242, 2419), (1699, 1781), (144, 2619), (2402, 2416), (144, 2040), (1700, 1782), (356, 1679), (2414, 2559)]

for i in range(budget-1):
  dynamic_diffs = np.zeros((vcount, vcount))
  dynamic_geo_dist = np.zeros((vcount, vcount))
  #shortest_dynamic_path_distance = []
  rmd_nodes = road_map_dynamic.vs
  iter = 0
  #nx_road_map = road_map.to_networkx()
  for v in range(len(rmd_nodes)-1):
    start_node = rmd_nodes[v].index
    print(v)
    for v2 in range(v+1, len(rmd_nodes)):
      short_path = 0
      end_node = rmd_nodes[v2].index
      if road_map_dynamic.are_connected(start_node, end_node):
        #print("connected")
        #dyn_geo = shortest_dynamic_path_distance[iter] #road_map[road_map.get_eid(start_node, end_node)]['geo_distance']
        short_path = road_map_dynamic.es[road_map_dynamic.get_eid(start_node, end_node)]['geo_distance']
        dyn_geo = short_path
      else:
        temp = road_map_dynamic.get_shortest_paths(start_node, to=end_node, weights = road_map_dynamic.es['geo_distance'], output = "epath")
        for e in temp[0]:
          short_path += road_map_dynamic.es[e]['geo_distance']
        a = rmd_nodes[v]['coordinates']
        b = rmd_nodes[v2]['coordinates']
        dyn_geo = math.sqrt((a[0] - b[0])**2 + (a[1]-b[1])**2)
      d_dif = short_path - dyn_geo #shortest_dynamic_path_distance[iter] - dyn_geo
      dynamic_geo_dist[v][v2] = dyn_geo
      dynamic_diffs[v][v2] = d_dif
      #iter+=1
        #short_path = nx.single_source_dijkstra(G = nx_road_map, source = start_node, target = end_node, weight='geo_distance')[0]
      #shortest_dynamic_path_distance.append(short_path)
  #write here
  #shortest_dynamic_path_distance = np.array(shortest_dynamic_path_distance)
  #shortest_dynamic_path_distance.shape
  #n = 20
  flat_d_difs = dynamic_diffs.flatten()
  sort_d_flat_indices = flat_d_difs.argsort()
  max_dyn_indices = sort_d_flat_indices[-1:]
  matrix_dyn_indices = np.unravel_index(max_dyn_indices, (2647, 2647))
  matrix_dyn_indices = list(matrix_dyn_indices)
  new_dynamic_edges.append((matrix_dyn_indices[0][0], matrix_dyn_indices[1][0]))
  road_map_dynamic.add_edge(matrix_dyn_indices[0][0], matrix_dyn_indices[1][0], weight = -1, geo_distance = actual_geo_distances[max_edge_indices[0][0]][max_edge_indices[1][0]])
  print(matrix_dyn_indices)

# plot the roads
fig, ax = plt.subplots(figsize=(15, 15), dpi = 200)
#map_img = plt.imread('map2.PNG')
#plt.figure(figsize=(15,15), dpi=200)
for e in road_map_dynamic.es:
    start = e.source
    end = e.target
    cur_edge = sorted([start,end])

    v1 = road_map_dynamic.vs[e.source]['coordinates']
    v2 = road_map_dynamic.vs[e.target]['coordinates']
    data = np.vstack([v1, v2])
    x = data[:, 0]
    y = data[:, 1]
    if cur_edge in new_dynamic_edges:
        print(cur_edge)
        plt.plot(x,y,'#FF0000')
    else:
        plt.plot(x, y, '#8ab4f7' )

# mark the source and destination
# source = tri_g.vs.select(display_name=source_address)[0].index
# target = tri_g.vs.select(display_name=dest_address)[0].index
# v1 = road_map.vs[source_idx]['coordinates']
# v2 = road_map.vs[dest_idx]['coordinates']
# data = np.vstack([v1, v2])
# x = data[:, 0]
# y = data[:, 1]
# plt.plot(x, y, 'bo')
#ax.set_xlim(BBox[0], BBox[1])
#ax.set_ylim(BBox[2], BBox[3])
ax.imshow(map_img, zorder = 0, extent = BBox, aspect = 'equal')

plt.axis('equal')
plt.show()

for i, edg in enumerate(new_dynamic_edges):
  start = edg[0]
  end = edg[1]
  print("\\", "textbf{", i+1, "} & ", edg, " & ", road_map_dynamic.es[road_map_dynamic.get_eid(start, end)]['geo_distance'], " \\\ \hline")

#22
road_map_time = deepcopy(tri_g_trimmed)

time_difference = np.zeros((vcount, vcount))
time_nodes = road_map_time.vs
iter = 0
for v in range(len(time_nodes)-1):
  start_node = time_nodes[v].index
  print(v)
  for v2 in range(v+1, len(time_nodes)):
    end_node = time_nodes[v2].index
    path_speed = shortest_path_distance[iter]/shortest_path_time[iter]
    time_difference[v][v2] = shortest_path_time[iter] - actual_geo_distances[v][v2]/path_speed
    iter+=1

print(len(time_nodes))
print(vcount)
print(max_time)

flat_time = time_difference.flatten()
sort_time = flat_time.argsort()
max_time = sort_time[-20:]
max_time_indices = list(np.unravel_index(max_time, (2647, 2647)))

new_time_edges = []
for i in range(20): #40 because there will be repititions (A-> B is same as B-> A)
    newedge = [max_time_indices[0][i], max_time_indices[1][i]]
    print("New edge nodes: ", newedge, " and the difference: ", time_difference[max_time_indices[0][i]][max_time_indices[1][i]])#new edge nodes and the difference )
    new_time_edges.append(newedge)

road_map_time = deepcopy(tri_g_trimmed) #ensure to use deepcopy
for edg in new_time_edges:
    start = edg[0]
    end = edg[1]
    dist = actual_geo_distances[start][end]# which distance to use?
    road_map_time.add_edge(start, end, weight = dist)

# plot the roads and highlight our new edges.
fig, ax = plt.subplots(figsize=(15, 15), dpi = 200)
#plt.figure(figsize=(15,15), dpi=200)
for e in road_map_time.es:
    start = e.source
    end = e.target
    cur_edge = sorted([start,end])

    v1 = road_map_time.vs[e.source]['coordinates']
    v2 = road_map_time.vs[e.target]['coordinates']
    data = np.vstack([v1, v2])
    x = data[:, 0]
    y = data[:, 1]
    if cur_edge in new_time_edges:
        print(cur_edge)
        #print(v1, v2)
        plt.plot(x,y,'#FF0000')#, linewidth = 4)
    else:
        plt.plot(x, y, '#8ab4f7')


ax.imshow(map_img, zorder = 0, extent = BBox, aspect = 'equal')
plt.axis('equal')
plt.show()

#23
road_map_time_dynamic = deepcopy(road_map)

budget = 19
new_dynamic_time_edges = []

def convert_index(idx, lngth):
  iter = 0
  xy = list(np.unravel_index(idx, (lngth, lngth)))
  x = xy[0]
  y = xy[1]
  for i in range(lngth-1):
    for j in range(i+1, lngth):
      if i == x and j == y:
        return iter
      iter+=1

d_max_time = sort_time[-1:]
d_indices = list(np.unravel_index(d_max_time, (2647, 2647)))
d_store = [d_indices[0][0], d_indices[1][0]]
wt = actual_geo_distances[d_store[0]][d_store[1]]/(shortest_path_distance[convert_index(d_max_time, 2647)]/shortest_path_time[convert_index(d_max_time,  2647)])
new_dynamic_time_edges.append(d_store)
road_map_time_dynamic.add_edge(source = d_store[0], target = d_store[1], weight = wt, geo_distance = actual_geo_distances[d_store[0]][d_store[1]])

print(road_map_time_dynamic.es[7756].source)
print(road_map_time_dynamic.es[7756].target)

#delete
new_dynamic_time_edges = []
new_times = []
for i, edg in enumerate(new_dynamic_time_edges):
  start = edg[0]
  end = edg[1]
  dist = actual_geo_distances[start][end]
  wg = new_times[i]
  road_map_time_dynamic.add_edge(source = start, target = end, weight = wg, geo_distance = dist)

for i in range(budget):
  #shortest_d_path_distance = []
  #shortest_d_path_time = []
  d_time_diffs = np.zeros((vcount, vcount))
  d_time = np.zeros((vcount, vcount))
  rmtd_nodes = road_map_time_dynamic.vs
  #nx_road_map = road_map.to_networkx()
  for v in range(len(rm_nodes)-1):
    start_node = rmtd_nodes[v].index
    #print(v)
    for v2 in range(v+1, len(rmtd_nodes)):
      short_d_path = 0
      short_d_time = 0
      end_node = rmtd_nodes[v2].index
      if road_map_time_dynamic.are_connected(start_node, end_node):
        #print("connected")
        short_d_path = road_map_time_dynamic.es[road_map_time_dynamic.get_eid(start_node, end_node)]['geo_distance']
        short_d_time = road_map_time_dynamic.es[road_map_time_dynamic.get_eid(start_node, end_node)]['weight']
      else:
        temp = road_map_time_dynamic.get_shortest_paths(start_node, to=end_node, weights = road_map_time_dynamic.es['geo_distance'], output = "epath")
        for e in temp[0]:
          short_d_path += road_map_time_dynamic.es[e]['geo_distance']
          short_d_time += road_map_time_dynamic.es[e]['weight']
        #short_path = nx.single_source_dijkstra(G = nx_road_map, source = start_node, target = end_node, weight='geo_distance')[0]
      #shortest_d_path_distance.append(short_path)
      #shortest_d_path_time.append(short_time)
      d_speed = short_d_path/short_d_time
      d_time_diffs[v][v2] = short_d_time - actual_geo_distances[v][v2]/d_speed
      d_time[v][v2] = actual_geo_distances[v][v2]/d_speed
  #write here
  max_d_time = d_time_diffs.flatten().argsort()[-1:]
  max_d_time_indices = list(np.unravel_index(max_d_time, (2647, 2647)))

  print(max_d_time_indices)
  new_td_edge = [max_d_time_indices[0][0], max_d_time_indices[1][0]]
  new_dynamic_time_edges.append(new_td_edge)
  road_map_time_dynamic.add_edge(source = new_td_edge[0], target = new_td_edge[1], weight = d_time[new_td_edge[0]][new_td_edge[1]], geo_distance = actual_geo_distances[new_td_edge[0]][new_td_edge[1]])
  #shortest_d_path_distance = np.array(shortest_d_path_distance)
  #shortest_d_path_time = np.array(shortest_d_path_time)
  #shortest_path_distance.shape
  #print(new_dynamic_time_edges)

#shortest_d_path_distance = []
  #shortest_d_path_time = []
d_time_diffs = np.zeros((vcount, vcount))
d_time = np.zeros((vcount, vcount))
rmtd_nodes = road_map_time_dynamic.vs
  #nx_road_map = road_map.to_networkx()
for v in range(len(rm_nodes)-1):
  start_node = rmtd_nodes[v].index
  print(v)
  for v2 in range(v+1, len(rmtd_nodes)):
    short_d_path = 0
    short_d_time = 0
    end_node = rmtd_nodes[v2].index
    if road_map_time_dynamic.are_connected(start_node, end_node):
      #print("connected")
      short_d_path = road_map_time_dynamic.es[road_map_time_dynamic.get_eid(start_node, end_node)]['geo_distance']
      short_d_time = road_map_time_dynamic.es[road_map_time_dynamic.get_eid(start_node, end_node)]['weight']
    else:
      temp = road_map_time_dynamic.get_shortest_paths(start_node, to=end_node, weights = road_map_time_dynamic.es['geo_distance'], output = "epath")
      temp2 = road_map_time_dynamic.get_shortest_paths(start_node, to=end_node, weights = road_map_time_dynamic.es['weight'], output = "epath")
      for e in temp[0]:
        short_d_path += road_map_time_dynamic.es[e]['geo_distance']
      for e2 in temp2[0]:
        short_d_time += road_map_time_dynamic.es[e2]['weight']
      #short_path = nx.single_source_dijkstra(G = nx_road_map, source = start_node, target = end_node, weight='geo_distance')[0]
    #shortest_d_path_distance.append(short_path)
    #shortest_d_path_time.append(short_time)
    d_speed = short_d_path/short_d_time
    d_time_diffs[v][v2] = short_d_time - actual_geo_distances[v][v2]/d_speed
    d_time[v][v2] = actual_geo_distances[v][v2]/d_speed
#write here
max_d_time = d_time_diffs.flatten().argsort()[-1:]
max_d_time_indices = list(np.unravel_index(max_d_time, (2647, 2647)))
#print(max_d_time_indices)
new_td_edge = [max_d_time_indices[0][0], max_d_time_indices[1][0]]
new_dynamic_time_edges.append(new_td_edge)
road_map_time_dynamic.add_edge(source = new_td_edge[0], target = new_td_edge[1], weight = d_time[new_td_edge[0]][new_td_edge[1]], geo_distance = actual_geo_distances[new_td_edge[0]][new_td_edge[1]])
#shortest_d_path_distance = np.array(shortest_d_path_distance)
#shortest_d_path_time = np.array(shortest_d_path_time)
#shortest_path_distance.shape
#print(new_dynamic_time_edges)

print(new_dynamic_time_edges)
tms =[]
for edg in new_dynamic_time_edges:
  tms.append(road_map_time_dynamic.es[road_map_time_dynamic.get_eid(edg[0], edg[1])]['weight'])
print(tms)
#print(road_map_time_dynamic.es[road_map_time_dynamic.get_eid(new_dynamic_time_edges[0], new_dynamic_time_edges[1])]['weight'])

# plot the roads
fig, ax = plt.subplots(figsize=(15, 15), dpi = 200)
#map_img = plt.imread('map2.PNG')
#plt.figure(figsize=(15,15), dpi=200)
for e in road_map_time_dynamic.es:
    start = e.source
    end = e.target
    cur_edge = sorted([start,end])

    v1 = road_map_time_dynamic.vs[e.source]['coordinates']
    v2 = road_map_time_dynamic.vs[e.target]['coordinates']
    data = np.vstack([v1, v2])
    x = data[:, 0]
    y = data[:, 1]
    if cur_edge in new_dynamic_time_edges:
        print(cur_edge)
        plt.plot(x,y,'#FF0000')
    else:
        plt.plot(x, y, '#8ab4f7' )

# mark the source and destination
# source = tri_g.vs.select(display_name=source_address)[0].index
# target = tri_g.vs.select(display_name=dest_address)[0].index
# v1 = road_map.vs[source_idx]['coordinates']
# v2 = road_map.vs[dest_idx]['coordinates']
# data = np.vstack([v1, v2])
# x = data[:, 0]
# y = data[:, 1]
# plt.plot(x, y, 'bo')
#ax.set_xlim(BBox[0], BBox[1])
#ax.set_ylim(BBox[2], BBox[3])
ax.imshow(map_img, zorder = 0, extent = BBox, aspect = 'equal')

plt.axis('equal')
plt.show()